/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2026 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f4xx.h"

void TIM2_Init(void);
void ADC1_Init(void);
void DMA2_Init(void);
void UART_Init(void);

void uart_send_char(char c);
void uart_send_uint(uint16_t val);

void DMA2_Stream0_IRQHandler(void);



volatile uint16_t adc_buffer[1];

void TIM2_Init(void)
{
    /* 1. Enable TIM2 clock */
    RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;

    /* 2. Disable timer during configuration */
    TIM2->CR1 &= ~TIM_CR1_CEN;

    /* 3. Set prescaler and auto-reload */
    TIM2->PSC = 1599;   // 16 MHz / (1599+1) = 10 kHz
    TIM2->ARR = 99;     // 10 kHz / (99+1)   = 100 Hz
    TIM2->EGR = TIM_EGR_UG;

    /* 4. Reset counter */
    TIM2->CNT = 0;

    /* 5. Select TRGO on update event */
    TIM2->CR2 &= ~TIM_CR2_MMS;
    TIM2->CR2 |= TIM_CR2_MMS_1;   // MMS = 010 → Update event

    /* 6. Enable auto-reload preload if needed (optional) */
    // TIM2->CR1 |= TIM_CR1_ARPE;

    /* 7. Start timer */
    TIM2->CR1 |= TIM_CR1_CEN;
}

void ADC1_Init(void)
{
    /* 1. Enable clocks */
    RCC->APB2ENR |= RCC_APB2ENR_ADC1EN;
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;

    /* 2. Configure PA0 as analog */
    GPIOA->MODER |= (3U << (0 * 2));   // Analog mode
    GPIOA->PUPDR &= ~(3U << (0 * 2));  // No pull-up/down

    /* 3. ADC common configuration */
    ADC->CCR = 0;   // Prescaler = PCLK2 / 2

    /* 4. ADC configuration */
    ADC1->CR1 = 0;  // 12-bit resolution

    ADC1->CR2 =
        ADC_CR2_DMA |          // Enable DMA
        ADC_CR2_DDS |          // DMA requests continuous
        ADC_CR2_EXTEN_0 |      // Trigger on rising edge
		(6U << ADC_CR2_EXTSEL_Pos);   // TIM2_TRGO

    /* 5. Sampling time for channel 0 */
    ADC1->SMPR2 |= ADC_SMPR2_SMP0_1;   // Moderate sampling time

    /* 6. Regular channel sequence: channel 0 */
    ADC1->SQR1 = 0;   // 1 conversion
    ADC1->SQR3 = 0;   // Channel 0 first

    /* 7. Enable ADC */
    ADC1->CR2 |= ADC_CR2_ADON;

        for (volatile int i = 0; i < 1000; i++); // ADC stabilize


}
void DMA2_Init(void)
{
    /* 1. Enable DMA2 clock */
    RCC->AHB1ENR |= RCC_AHB1ENR_DMA2EN;

    /* 2. Disable stream before configuration */
    DMA2_Stream0->CR &= ~DMA_SxCR_EN;
    while (DMA2_Stream0->CR & DMA_SxCR_EN);

    /* 3. Clear interrupt flags */
    DMA2->LIFCR =
        DMA_LIFCR_CTCIF0 |
        DMA_LIFCR_CHTIF0 |
        DMA_LIFCR_CTEIF0 |
        DMA_LIFCR_CDMEIF0 |
        DMA_LIFCR_CFEIF0;

    /* 4. Configure addresses */
    DMA2_Stream0->PAR  = (uint32_t)&ADC1->DR;
    DMA2_Stream0->M0AR = (uint32_t)adc_buffer;
    DMA2_Stream0->NDTR = 1;

    /* 5. Configure DMA stream */
    DMA2_Stream0->CR =
        (0U << DMA_SxCR_CHSEL_Pos) |  // Channel 0
        DMA_SxCR_MINC |               // Memory increment
        DMA_SxCR_PSIZE_0 |             // Peripheral size = 16-bit
        DMA_SxCR_MSIZE_0 |             // Memory size = 16-bit
        DMA_SxCR_TCIE |                // Transfer complete interrupt
        DMA_SxCR_CIRC;                 // Circular mode (recommended)

    /* 6. Enable NVIC interrupt */
    NVIC_EnableIRQ(DMA2_Stream0_IRQn);

    /* 7. Enable DMA stream */
    DMA2_Stream0->CR |= DMA_SxCR_EN;
}
void DMA2_Stream0_IRQHandler(void)
{
    /* Check transfer complete flag */
    if (DMA2->LISR & DMA_LISR_TCIF0)
    {
        /* Clear transfer complete flag */
        DMA2->LIFCR |= DMA_LIFCR_CTCIF0;

        uint16_t adc_val = adc_buffer[0];

        /* Send ADC value over UART */
        uart_send_uint(adc_val);
        uart_send_char('\r');
        uart_send_char('\n');
    }
}
void UART_Init(void)
{
    /* Enable clocks */
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;
    RCC->APB1ENR |= RCC_APB1ENR_USART2EN;

    /* PA2 → USART2_TX (AF7) */
    GPIOA->MODER &= ~(3U << (2 * 2));
    GPIOA->MODER |=  (2U << (2 * 2));
    GPIOA->AFR[0] &= ~(0xFU << (2 * 4));
    GPIOA->AFR[0] |=  (7U << (2 * 4));

    /* Baud = 115200 @ 16 MHz */
    USART2->BRR = 16000000 / 115200;

    /* Enable transmitter and USART */
    USART2->CR1 = USART_CR1_TE | USART_CR1_UE;
}

void uart_send_char(char c)
   {
       while (!(USART2->SR & USART_SR_TXE));
       USART2->DR = c;
   }

   void uart_send_uint(uint16_t val)
   {
       char buf[6];
       int i = 0;

       if (val == 0)
       {
           uart_send_char('0');
           return;
       }

       while (val > 0)
       {
           buf[i++] = (val % 10) + '0';
           val /= 10;
       }

       while (i--)
           uart_send_char(buf[i]);
   }
int main(void)
{
	
	    DBGMCU->CR |= DBGMCU_CR_DBG_SLEEP; //debugging live experissions
    UART_Init();
    DMA2_Init();    // 1. DMA first
    ADC1_Init();    // 2. ADC
    TIM2_Init();    // 3. Timer (starts triggering ADC)

    __enable_irq();

    while (1)    {
        __WFI();    
    }


}

